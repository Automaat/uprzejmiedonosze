{% set leftButton = '' %}
{% set rightButton = '' %}

{% set title = 'Generator' %}
{% set shortTitle = 'Generator' %}
{% set description = 'Generator' %}
{% set mainClass = 'how' %}

{% extends "base.html.twig" %}
{% block footer %}
{% endblock %}
{% block main %}

<style>
#generator>section>fieldset { margin-top: 0.5em; }
fieldset>label {
 display: flex;
 align-items: center;
 border: 1px solid #eee;
 margin-bottom: 1em;
 padding: 0.5em;
 border-radius: 0.75em;
}
fieldset>label>input {
 flex-shrink: 0;
 margin: 0 8px 0 0;
 align-self: center;
 display: flex !important;
 width: 1em;
}
    .form-group {
        margin-bottom: 15px;
    }
    .topics-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 10px;
        margin-bottom: 15px;
    }
    .topic-desc {
        font-size: 0.85em;
        color: #666;
        margin-top: 2px;
    }
    input[type="text"], 
    select, 
    textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
    }
    #output {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 4px;
        min-height: 200px;
        background-color: white;
        white-space: pre-wrap;
        font-family: 'Courier New', Courier, monospace;
    }
    .status {
        margin-top: 10px;
        font-style: italic;
        color: #7f8c8d;
    }
    #generator>section {
        display: none;
    }
    #generator>section.active {
        display: block !important;
    }
    #generator>header { display: flex; align-items: center; min-height: 2em; }
    #generator>header>a { display: none; }
    #generator>header>span { position: absolute; left: 50%; transform: translateX(-50%); }
    /* these are unlike rest of website */
    #generator>section>div,
    #generator>section>h1 { text-align: center; }
    #generator>section>nav { margin-top: 1em; border-top: 1px solid #e7e7e7; padding-top: 1em; text-align: center; }
    #generator>section>nav>button,
    #generator>section>nav>a { width: 85%; margin-top: 0.25em; margin-bottom: 0.25em; }

    #generator>section>div#output { text-align: left; font-family: 'Red Hat Display'; }
</style>


<div id='generator' class='rd25'>
  <header>
    <a data-action="prev">&lt; Wróc</a>
    <span></span>
  </header>

  <section id="step-0" class="active">
    <h1>Uprzejmy generator pism</h1>
    {% if isPatron %}
    <h4>Narzędzie jest w fazie testowej</h4>
    <p>Nie wysyłaj jeszcze wygenerowanych pism. Będę zobowiązany za feedback na adres <a href="mailto:szymon@uprzejmiedonosze.net">szymon@uprzejmiedonosze.net</a>.
    Pamiętaj, że generowanie każdego wniosku kosztuje (od kilku do kilkudziesięciu groszy, w zależności od ustawień, które tuninguję).
    Staraj się nie przekroczyć 10 prób.</p>
    {% else %}
    <h4>Narzędzie jest w fazie testowej dostępnej tylko dla Patronów i Patronek</h4>
    <p>Po fazie zamkniętych testów zostanie udostępnione wszystkim użytkownikom Uprzejmie Donoszę.</p>
    {% endif %}
    <nav>
        <button class="button" type="button" data-action="next" {% if not isPatron %}disabled{% endif %}>Dalej</button>
    </nav>
  </section>

  <section id="step-1">
    <h1>Co Cię najbardziej wkurza w pato parkowaniu?</h1>
    <div id="topicError">Wybierz do 3 opcji.</div>
    <fieldset id="fs-topics">
    </fieldset>
    <nav>
        <button class="button" type="button" data-action="next" {% if not isPatron %}disabled{% endif %}>Dalej</button>
    </nav>
  </section>

  <section id="step-2">
    <h1>Wybierz charakter pisma</h1>
    <p>Jakiego tonu chcesz użyć w swojej wiadomości?</p>
    <fieldset id='fs-types'>
    </fieldset>
    <nav>
        <button class="button" type="button" data-action="next" {% if not isPatron %}disabled{% endif %}>dalej</button>
    </nav>
  </section>
  <section id="step-3">
    <h1>wybierz adresata</h1>
    <fieldset id='fs-targets'>
    </fieldset>
    <nav>
        <button class="button" type="button" data-action="next" {% if not isPatron %}disabled{% endif %}>dalej</button>
    </nav>
  </section>

  <section id="step-4">
    <h1>wybierz adresata</h1>
    <fieldset id='fs-recipients'>
    </fieldset>
    <nav>
        {% if isPatron %}
        <button data-action="generate" class="button cta">generuj pismo</button>
        {% else %}
        <button class="button disabled">generuj pismo</button>
        {% endif %}
    </nav>
  </section>


  <section id="step-5">
    <h1>Wygenerowane pismo</h1>
    <div class="status" id="status">Gotowy do generowania</div>
    <div id="output"></div>
    <nav>
        <a class="button cta" id='mailtoButton' href="#" style="display: none;">Wyślij przez domyślny klient e-mail</a>
        <a class="button cta" id='gmailButton' href="#" target="_blank" style="display: none;">Wyślij przez GMail</a>
        <br />
        <a class="button" id='generateButton' href="#" data-action="restart">Generuj kolejne pismo</button>
    </nav>
  </section>
</div>



<script>
    // Global variables
    let topicsData = [];
    let formTypesData = {};
    let targetsData = {};
    let currentStep = 0;
    const totalSteps = document.querySelectorAll("#generator>section").length;

    function showStep(stepNumber) {
        document.querySelectorAll('#generator>section').forEach(section => {
            section.classList.remove('active');
        });

        const currentSection = document.getElementById(`step-${stepNumber}`);
        if (currentSection) {
            currentSection.classList.add('active');
        }

        document.querySelector('#generator>header>span').textContent = `Krok ${stepNumber + 1} z ${totalSteps}`;
        if (stepNumber>0) {
          document.querySelector('#generator>header>a').style.display='block';
        } else {
          document.querySelector('#generator>header>a').style.display='none';
        }

        currentStep = stepNumber;
    }

    function prevStep() {
        if (currentStep > 0) {
          showStep(currentStep-1);
        }
    }

    function nextStep() {
        if (currentStep < totalSteps - 1) {
            // Validate current step before proceeding
            if (validateCurrentStep()) {
                showStep(currentStep + 1);
            }
        }
    }

    function validateCurrentStep() {
        switch(currentStep) {
            case 0:
                return true; // No validation needed for intro step
            case 1:
                return validateTopics();
            case 2:
                return renderTargets();
            case 3:
                return validateForm();
            default:
                return true;
        }
    }

    function validateForm() {
        const formType = document.querySelector('input[name="formType"]:checked')?.value;
        const target = document.querySelector('input[name="target"]:checked')?.value;

        if (!formType) {
            alert('Proszę wybrać typ pisma');
            return false;
        }

        if (!target) {
            alert('Proszę wybrać adresata');
            return false;
        }

        return true;
    }
    
    function restartWizard() {
        // Reset form
        document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        document.querySelectorAll('input[name="formType"]').forEach(radio => radio.checked = false);
        document.querySelectorAll('input[name="target"]').forEach(radio => radio.checked = false);
        document.getElementById('output').textContent = '';
        document.getElementById('status').textContent = 'Gotowy do generowania';
  
        document.getElementById('mailtoButton').href = '#';
        document.getElementById('mailtoButton').style.display = 'none';
        document.getElementById('gmailButton').href = '#';
        document.getElementById('gmailButton').style.display = 'none';

        // Go back to step 1 (skip intro)
        showStep(1);
    }

    // Initialize the page
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            showStep(0);
            // Load topics
            const topicsResponse = await fetch('/generator/topics');
            topicsData = await topicsResponse.json();
            renderTopics();

            // Load form types
            const formTypesResponse = await fetch('/generator/form_types');
            formTypesData = await formTypesResponse.json();
            renderFormTypes();

            // Load targets
            const targetsResponse = await fetch('/generator/targets');
            targetsData = await targetsResponse.json();

            // Add event listeners for navigation buttons
            document.addEventListener('click', (e) => {
                if (e.target.dataset.action === 'next') {
                    nextStep();
                } else if (e.target.dataset.action === 'prev') {
                    prevStep();
                } else if (e.target.dataset.action === 'restart') {
                    restartWizard();
                } else if (e.target.dataset.action === 'generate') {
                    generate();
                }
            });
        } catch (error) {
            console.error('Error initializing data:', error);
            alert('Wystąpił błąd podczas ładowania danych. Odśwież stronę i spróbuj ponownie.');
        }
    });
    
    // Render topics checkboxes
    function renderTopics() {
        const container = document.getElementById('fs-topics');

        container.innerHTML = Object.entries(topicsData).map(([id, topic]) => `
            <label>
              <input type="checkbox" name='topics[]' value="${id}" onchange="validateTopics()">
              ${topic.title}
            </label>
        `).join('');
    }
    
    // Render form types radio buttons
    function renderFormTypes() {
        const container = document.getElementById('fs-types');

        container.innerHTML = Object.entries(formTypesData).map(([id, data], index) => `
            <label>
              <input type="radio" name="formType" value="${id}" onchange="renderTargets()" ${index === 0 ? 'checked' : ''}>
              ${data || id}
            </label>
        `).join('');
    }
    
    // Render targets based on selected form type
    function renderTargets() {
        const formType = document.querySelector('input[name="formType"]:checked')?.value;
        const container = document.getElementById('fs-targets');

        container.innerHTML = '';

        if (!formType) {
            container.innerHTML = '<p>Najpierw wybierz typ pisma</p>';
            return;
        }

        // Filter targets that support the selected form type and have recipient defined
        const availableTargets = Object.entries(targetsData)
            .filter(([_, target]) => target.forms.includes(formType))
            .filter(([_, target]) => target.recipient)   // @FIXME implement proper recipient selection in separate for those cases
            .sort((a, b) => a[1].title.localeCompare(b[1].title));

        container.innerHTML = availableTargets.map(([id, target]) => `
            <label>
              <input type="radio" name="target" data-recipient="${target.recipient || ''}" onchange="checkRecipient()" value="${id}">
              ${id}
            </label>
        `).join('');

        return true;
    }

    // check recipient and possible next steps
    function checkRecipient() {
        const selectedTarget = document.querySelector('input[name="target"]:checked');
        const selectedTargetValue = selectedTarget?.value;
        const selectedTargetRecipient = selectedTarget?.dataset?.recipient;
        const actionButton = document.querySelector('#generator>section#step-3>nav>button');

        if (selectedTargetRecipient) {    // we know who is the recipient
          actionButton.innerHTML = 'Generuj';
          actionButton.dataset.action = 'generate';
          actionButton.disabled = false;
          actionButton.classList.remove('disabled');
        } else if (selectedTargetValue) { // we need to perform additional selection
          actionButton.innerHTML = 'Dalej';
          actionButton.dataset.action = 'next';
          actionButton.disabled = false;
          actionButton.classList.remove('disabled');
        } else {                          // fallback
          actionButton.disabled = true;
          actionButton.classList.add('disabled');
        }

        return true;
    }
    
    // Validate that 1-3 topics are selected
    function validateTopics() {
        const selectedTopics = document.querySelectorAll('fieldset#fs-topics input[type="checkbox"]:checked');
        const errorElement = document.getElementById('topicError');
        
        if (selectedTopics.length === 0 || selectedTopics.length > 3) {
            errorElement.style.color = 'red';
            return false;
        }
        
        errorElement.style.color = '';
        return true;
    }
    
    // Get selected topic IDs
    function getSelectedTopicIds() {
        return Array.from(document.querySelectorAll('#fs-topics input[type="checkbox"]:checked'))
            .map(checkbox => checkbox.value);
    }
    
    // Generate button click handler
    async function generate(){
        const button = document.getElementById('generateButton');
        const output = document.getElementById('output');
        const status = document.getElementById('status');
        
        // Validate form
        if (!validateForm()) {
            return;
        }
        
        const topicIds = getSelectedTopicIds();
        const formType = document.querySelector('input[name="formType"]:checked')?.value;
        const target = document.querySelector('input[name="target"]:checked')?.value;
                    
        // Clear previous output and move to results step
        output.textContent = '';
        showStep(5);
        
        try {
            // Build URL with query parameters
            const params = new URLSearchParams();
            params.append('topics', JSON.stringify(topicIds));
            params.append('form_type', formType);
            params.append('target', target);
            
            button.classList.add('disabled')
            
            // Add time fillers for the countdown
            const timeFillers = [
                'Rozpoczynam generowanie...',
                'Czytam Miejską Agendę Parkingową...',
                'Czytam Przepisy o Ruchu Drogowym...',
                'Szukam absurdalnych przykładów dla urozmaicenia pisma...',
                'Sprawdzam co w temacie ma do powiedzenia NIK...',
                'Czytam decyzję NSA z 2018 roku...',
                'Patrzę na możliwe rozwiązania...'
            ].sort(() => Math.random() - 0.5);
            
            let countdown = 40;
            let countdownInterval;
            
            // Start countdown
            const startCountdown = () => {
                countdownInterval = setInterval(() => {
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        return;
                    }
                    countdown--;
                    const filler = timeFillers[Math.floor(timeFillers.length * (countdown / 40))];
                    status.textContent = `${filler} (${countdown}s)`;
                }, 1000);
            };
            
            // Start the countdown
            startCountdown();
            
            const response = await fetch(`/generator/stream?${params.toString()}`, {
                method: 'GET',
                headers: {
                    'Accept': 'text/event-stream'
                }
            });
            
            // Check if response is OK
            if (!response.ok) {
                const error = await response.text();
                throw new Error(error);
            }
            
            // Clear the countdown when we start reading
            if (countdownInterval) clearInterval(countdownInterval);
            
            // Process the stream as text
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) {
                    status.textContent = 'Zakończono generowanie';
                    break;
                }
                
                // Decode the chunk
                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // Process complete events (they end with double newline)
                const events = buffer.split('\n\n');
                buffer = events.pop() || ''; // Keep incomplete event in buffer
                
                for (const event of events) {
                    if (!event.startsWith('data: ')) continue;
                    
                    const eventData = event.slice(6).trim();
                    
                    // Check for done signal
                    if (eventData === '[DONE]') {
                        status.textContent = 'Zakończono generowanie';
                        continue;
                    }
                    
                    try {
                        const data = JSON.parse(eventData);
                        
                        if (data.error) {
                            throw new Error(data.error);
                        }

                        if (data.content) {
                            output.textContent += data.content;
                            // Auto-scroll to bottom
                            output.scrollTop = output.scrollHeight;
                        }
                    } catch (e) {
                        console.error('Error parsing event:', e);
                    }
                }
            }

            // Show and populate email links after successful generation
            populateEmailLinks();

        } catch (error) {
            console.error('Error:', error);
            const parsed = JSON.parse(error.message);
            if (parsed.error) {
                status.textContent = `Błąd: ${parsed.error}`;
            } else {
                status.textContent = `Błąd: ${error.message}`;
            }
        } finally {
            button.classList.remove('disabled')
        }
    };

    // Function to populate email links with recipient and content
    function populateEmailLinks() {
        const selectedTarget = document.querySelector('input[name="target"]:checked');
        const recipient = selectedTarget?.dataset?.recipient;
        const content = document.getElementById('output').textContent;

        if (!recipient || !content) {
            return;
        }

        const subject = 'Pismo w sprawie parkowania';

        // Populate mailto link
        const mailtoUrl = `mailto:${recipient}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(content)}`;
        document.getElementById('mailtoButton').href = mailtoUrl;
        document.getElementById('mailtoButton').style.display = 'inline-block';

        // Populate Gmail link
        const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(recipient)}&su=${encodeURIComponent(subject)}&body=${encodeURIComponent(content)}`;
        document.getElementById('gmailButton').href = gmailUrl;
        document.getElementById('gmailButton').style.display = 'inline-block';
    }
</script>


{% endblock %}
